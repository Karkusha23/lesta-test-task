# Тестовое задание для вакансии Intern C++ Programmer в Lesta Games
## 1 вопрос. Четность числа (```even.h```)
### Первый вариант ```value % 2 == 0```
* Плюсы:
  + Простота
  + Читаемость
* Минусы:
  + Дорогостоящая операция деления
### Второй вариант ```(value & 1) == 1```
* Плюсы:
  + Быстрая операция побитовой конъюнкции, проверяем только последний бит числа
* Минусы:
  + Плохая читаемость
## 2 вопрос. Кольцевой буфер
В файле ```ringbuffer.h``` представлен интерфейс, через который реализованы 2 класса
### Кольцевой буфер на массиве (```ringbufferarray.h```)
* Плюсы
  + Быстрый (```O(1)```) доступ к произвольному элементу буфера
* Минусы
  + Дорогостоящая операция изменения размера буфера с перекопированием памяти

Расположение в едином непрерывном участке памяти может быть как плюсом, так и минусом - при хранении небольших элементов имеем быстрый оптимизированный доступ, при хранении больших элементов может быть невозможно найти непрерывный участок памяти
### Кольцевой буфер на замкнутом односвязном списке (```ringbufferlist.h```)
* Плюсы
  + Быстрая операция изменения размера буфера, особенно на увеличение
* Минусы
  + Медленный доступ к произвольным элементам
  + Дорогостоящий переход по указателю в разные участки памяти

Обратно ситуации с кольцевым буфером на массиве, кольцевой буфер на списке больше подходит для хранения больших элементов, в таком случае отсутствие необходимости в непрерывном участке памяти является преимуществом, а при хранении небольших элементов слишком большую часть памяти в узле списка занимает указатель на следующий узел
## 3 вопрос. Сортировка
Трудоемкость алгоритмов сортировки, а следовательно, и количество процессорных тиков, зависит от особенностей входных данных

Для целых чисел существуют несколько алгоритмов, которые могут работать за линейное время, например,
* Карманная сортировка (Bucket sort)
* Сортировка подсчетом (Counting sort)
* Поразрядная сортировка (Radix sort)

Однако, карманная сортировка эффективно работает только на массивах, элементы которого равномерно распределены на некотором отрезке, а сортировка подсчетом - при небольшом количестве возможных значений элементов массива

Поразрядная сортировка, в то же время, не имеет сильной зависимости от особенностей входных данных, поэтому была выбрана именно она. Сложность алгоритма - ```O(mn)```, где ```n``` - длина массива, ```m``` - количество значений, которые может принимать каждый разряд

Далее стоит вопрос о том, сколько бит стоит брать в качестве разряда. С одной стороны, чем больше количество бит, тем меньше итераций алгоритма, и тем меньше итоговое время. С другой стороны, с количеством бит разряда экспоненциально растет количество требуемой памяти, а следовательно, и обходов массива корзин, что в случае 32-битных чисел может быть существенно

Количество бит в разряде должно быть таким, чтобы мощность множества значений разрядов была сопоставима с количеством элементов массива, то есть, например, если количество элементов меньше 50000, эффективнее использовать 8-битные разряды, а если больше, то 16-битные

Реализация алгоритма представлена в ```sort.h```
